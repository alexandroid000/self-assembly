#!/usr/bin/env python

# bounce.py
# This program simulates the bouncing of balls
# under various bouncing strategies
#
# Written by Steve LaValle
# November 2011

import sys, random, math, pygame
from pygame.locals import *
from math import sqrt,cos,sin,atan2,pi
from time import sleep

#constants
XDIM = 500
YDIM = 500
WINSIZE = [XDIM, YDIM]
EPSILON = 1.0
NUMBOUNCES = 100000
MAXDIST = 10000000.0

# Some initial polygons
# Use these below (inside main() to set the initial shape poly
square = [(250,250),(-250,250),(-250,-250),(250,-250)]
irrsquare = [(51.5,50),(-50,51.5),(-51.5,-50),(50,-50)]
triangle = [(250,-250),(0,250),(-250,-250)]
smallsquare = [(1,1),(-1,1),(-1,-1),(1,-1)]
smalltriangle = [(1,-1), (0,1), (-1,-1)]
thintriangle = [(-100,0),(0,-1),(100,0)]
thintriangle2 = [(0,-1),(100,0),(0,1)]
poly1 = [(200,-100), (210,50), (100,200), (0,150), (-50,200), (-150,100), (-200,10), (-140,-30), (-220, -200), (100, -180), (150,50)]
poly2 = [(200,-100), (210,50), (100,200), (0,150), (-50,200), (-150,100), (-200,10), (-140,-30), (-220, -200), (-150, -200), (-50,-5), (80,-5), (100, -180), (150,50)]
poly3 = [(200,-100), (210,50), (100,200), (0,150), (-50,200), (-150,100), (-200,10), (-140,-30), (-220, -200), (100, -200), (-100, -100), (-50,-5), (80,-5), (100, -180), (150,50)]
tworooms = [(-250,-250), (-10,-250), (-10,240), (10,240), (10,-250), (250,-250), (250, 250), (-250, 250)] 
tworooms2 = [(-250,-250), (-50,-250), (-50,240), (50,240), (50,-250), (250,-250), (250, 250), (-250, 250)] 
bigpoly = [(10.284109,990.061662),
(10.284109,950.174263),
(170.174960,970.184987),
(260.484751,960.648794),
(100.112360,910.420912),
(60.741573,930.833780),
(00.321027,910.018767),
(10.605136,750.469169),
(30.531300,800.294906),
(40.173355,890.812332),
(110.075441,840.718499),
(170.977528,870.399464),
(290.855538,730.592493),
(520.166934,800.563003),
(450.906902,810.367292),
(320.263242,760.943700),
(260.805778,850.656836),
(380.844302,950.308311),
(400.449438,900.482574),
(340.670947,860.193029),
(380.041734,820.975871),
(460.227929,920.091153),
(470.993579,950.576408),
(530.772071,880.471850),
(450.104334,840.986595),
(580.105939,810.233244),
(570.303371,750.603217),
(510.685393,770.077748),
(550.216693,700.643432),
(480.314607,750.335121),
(490.277689,670.560322),
(440.301766,750.469169),
(400.288925,650.549598),
(340.831461,710.447721),
(260.645265,680.498660),
(170.656501,800.831099),
(70.704655,810.903485),
(30.531300,710.045576),
(110.396469,570.908847),
(190.743178,600.723861),
(100.272873,730.324397),
(130.162119,740.798928),
(210.669342,660.756032),
(210.508828,570.506702),
(240.719101,550.764075),
(130.001605,550.630027),
(180.619583,500.938338),
(80.346709,550.093834),
(120.520064,470.453083),
(50.136437,560.300268),
(60.260032,630.538874),
(10.605136,620.466488),
(70.865169,470.721180),
(30.852327,470.721180),
(30.049759,540.289544),
(00.000000,520.949062),
(20.247191,430.833780),
(70.223114,430.833780),
(80.346709,400.080429),
(10.605136,410.286863),
(00.963082,370.131367),
(20.407705,360.193029),
(30.370787,390.410188),
(80.667737,370.667560),
(70.544141,340.182306),
(50.296950,350.388740),
(50.778491,380.069705),
(40.173355,380.203753),
(30.210273,330.378016),
(10.123596,330.378016),
(00.642055,300.965147),
(60.420546,300.831099),
(100.112360,340.450402),
(150.730337,310.501340),
(110.075441,290.758713),
(100.433387,320.171582),
(70.544141,270.882038),
(00.481541,270.613941),
(60.741573,260.005362),
(40.012841,210.849866),
(00.481541,210.715818),
(50.457464,180.364611),
(00.000000,160.353887),
(70.383628,140.477212),
(00.160514,110.796247),
(80.507223,100.321716),
(40.654896,80.445040),
(10.444623,100.857909),
(00.000000,70.104558),
(110.396469,40.825737),
(110.235955,90.249330),
(140.767255,60.970509),
(180.780096,40.155496),
(120.199037,20.144772),
(410.733547,00.000000),
(460.869984,170.292225),
(330.547352,160.756032),
(340.991974,100.991957),
(400.609952,130.538874),
(370.239165,60.434316),
(190.422151,60.702413),
(100.914928,150.013405),
(140.446228,280.686327),
(180.940610,260.407507),
(140.767255,180.096515),
(220.311396,100.187668),
(290.373997,90.383378),
(320.423756,190.705094),
(240.719101,210.715818),
(270.447833,260.005362),
(390.165329,190.034853),
(450.264848,270.211796),
(350.152488,320.171582),
(310.460674,400.348525),
(320.744783,430.297587),
(200.224719,310.769437),
(120.520064,360.193029),
(120.199037,420.761394),
(180.940610,430.565684),
(320.102729,550.898123),
(300.016051,600.187668),
(360.597111,600.723861),
(380.362761,550.227882),
(310.621188,490.329759),
(240.879615,430.833780),
(160.372392,400.348525),
(170.335474,350.924933),
(230.756019,360.461126),
(280.410915,410.554960),
(280.892456,440.772118),
(310.621188,450.844504),
(380.683788,390.544236),
(480.314607,320.707775),
(470.351525,240.798928),
(560.019262,240.128686),
(540.414125,160.621984),
(470.993579,80.847185),
(600.995185,20.144772),
(730.033708,20.144772),
(940.221509,20.680965),
(980.555377,110.528150),
(970.592295,220.386059),
(870.800963,200.777480),
(870.961477,120.466488),
(820.664526,70.372654),
(730.515249,80.579088),
(610.155698,60.702413),
(600.192616,210.983914),
(710.749599,210.313673),
(660.773676,140.611260),
(820.504013,110.662198),
(850.874799,150.951743),
(780.170144,160.353887),
(790.133226,240.530831),
(960.468700,250.201072),
(830.788122,270.479893),
(770.849117,280.686327),
(870.640449,300.697051),
(890.887640,350.254692),
(850.714286,390.142091),
(830.627608,330.378016),
(710.910112,300.965147),
(750.601926,220.788204),
(690.983949,240.128686),
(660.131621,300.160858),
(610.476726,250.737265),
(540.093098,290.624665),
(540.253612,360.327078),
(390.325843,450.174263),
(590.069021,410.018767),
(450.585875,500.000000),
(590.229535,440.101877),
(590.390048,500.134048),
(530.451043,470.587131),
(560.982343,520.680965),
(490.277689,520.144772),
(520.969502,560.032172),
(510.845907,600.053619),
(420.857143,500.536193),
(440.141252,610.528150),
(530.290530,610.528150),
(650.971108,430.297587),
(580.426966,360.997319),
(790.454254,360.997319),
(710.428571,400.348525),
(760.243981,430.029491),
(680.860353,470.319035),
(730.515249,560.166220),
(840.269663,520.278820),
(790.775281,470.587131),
(750.120385,520.815013),
(730.996790,480.659517),
(820.022472,440.504021),
(870.800963,500.000000),
(930.900482,470.453083),
(820.182986,410.420912),
(880.924559,420.627346),
(930.258427,380.605898),
(930.418941,300.563003),
(890.887640,280.686327),
(980.073836,270.747989),
(960.308186,330.780161),
(990.197432,330.780161),
(990.036918,390.008043),
(990.197432,510.206434),
(960.629213,540.021448),
(950.024077,580.713137),
(910.653291,550.227882),
(880.121990,590.249330),
(860.998395,540.423592),
(810.861958,600.187668),
(780.491172,560.836461),
(770.528090,640.343164),
(650.489567,650.415550),
(700.626003,620.198391),
(670.094703,560.434316),
(600.995185,670.560322),
(630.242376,810.769437),
(790.454254,800.965147),
(790.775281,790.088472),
(640.526485,770.882038),
(670.415730,670.560322),
(740.638844,700.241287),
(820.022472,630.002681),
(960.950241,610.528150),
(1000.000000,730.726542),
(920.295345,740.396783),
(890.085072,690.705094),
(840.911717,820.573727),
(950.345104,830.914209),
(950.987159,990.597855),
(910.974318,880.471850),
(900.690209,990.597855),
(890.085072,880.337802),
(860.356340,940.369973),
(880.924559,990.463807),
(860.035313,990.463807),
(830.627608,920.761394),
(840.911717,870.265416),
(810.059390,870.265416),
(800.577849,1000.000000),
(770.849117,880.069705),
(750.120385,990.463807),
(730.515249,900.214477),
(720.391653,990.597855),
(650.008026,990.597855),
(670.255217,960.648794),
(670.736758,910.554960),
(730.354735,860.327078),
(660.613162,850.388740),
(620.118780,920.359249),
(610.958266,990.061662),
(510.043339,990.329759)]


def PolyToWindowScale(poly):
    newpoly = []
    for p in poly:
        newpoly.append((p[0]/2.0,YDIM - p[1]/2.0))
    return newpoly

def PointToWindowScale(p):
     return (p[0]/2.0,YDIM - p[1]/2.0)


# Do we have theta1 <= theta <= theta2 (mod 2pi) ?
# It is just a particular cyclic permutation
def AngleBetween(theta,theta1,theta2):
    return (((theta1 <= theta) and (theta <= theta2)) or \
            ((theta2 <= theta1) and (theta1 <= theta)) or \
            ((theta <= theta2) and (theta2 <= theta1)))

def IsLeftTurn(p,q,r):
    return q[0]*r[1] + p[0]*q[1] + r[0]*p[1] - \
           (q[0]*p[1] + r[0]*q[1] + p[0]*r[1]) > 0


def IsRightTurn(p,q,r):
    return q[0]*r[1] + p[0]*q[1] + r[0]*p[1] - \
           (q[0]*p[1] + r[0]*q[1] + p[0]*r[1]) < 0

# Do we have theta1 <= theta <= theta2 (mod 2pi) ?
# It is just a particular cyclic permutation
def AngleBetween(theta,theta1,theta2):
    return (((theta1 <= theta) and (theta <= theta2)) or \
            ((theta2 <= theta1) and (theta1 <= theta)) or \
            ((theta <= theta2) and (theta2 <= theta1)))

def AngleDistance(theta1,theta2):
    d = abs(theta1-theta2)
    return min(d,2.0*pi-d)

def AngleDifference(theta1,theta2):
    d = theta2 - theta1
    if (d < pi):
        d += 2.0*pi;
    if (d > pi):
        d -= 2.0*pi;
    return d

def PointDistance(p,q):
    return sqrt((p[0]-q[0])*(p[0]-q[0])+(p[1]-q[1])*(p[1]-q[1]))

def FixAngle(theta):
    return theta % (2.0*pi)

# n is the inward edge normal (in degrees 0 to 2pi)

def PerformBounce(s,bp,n,strategy):

    # Random bounce
    if strategy == 0:
        dir = n + random.random()*pi - pi/2.0
    elif strategy == 1:
    # Right angle bounce
        dir = s[2] + pi/2.0
        if AngleDistance(dir,n) > pi/2.0:
            dir += pi
    elif strategy == 2:
    # Billiard bounce
        rebound = FixAngle(s[2] + pi)
#    print "ad:",AngleDifference(rebound,n),"rebound:",rebound,"n:",n
        dir = rebound + 2.0*AngleDifference(rebound,n)
    elif strategy == 3:
    # Normal bounce
        dir = n

    dir = FixAngle(dir)
    if AngleDistance(dir,n) > pi/2.0:
        print "Error: Illegal bounce.  n:",n,"dir:",dir
#    print "n:",n,"dir:",dir,"angledist:",AngleDistance(dir,n)
    return (bp[0], bp[1], dir)


def IsLeftTurn(p,q,r):
    return q[0]*r[1] + p[0]*q[1] + r[0]*p[1] - \
           (q[0]*p[1] + r[0]*q[1] + p[0]*r[1]) > 0


def IsRightTurn(p,q,r):
    return q[0]*r[1] + p[0]*q[1] + r[0]*p[1] - \
           (q[0]*p[1] + r[0]*q[1] + p[0]*r[1]) < 0


# start point, boundary point, edge p1, edge p2
def BouncePointInEdge(sp,bp,ep1,ep2):
    return ((IsLeftTurn(sp,bp,ep2) and
             IsRightTurn(sp,bp,ep1)) or
            (IsRightTurn(sp,bp,ep2) and
             IsLeftTurn(sp,bp,ep1)))


def main():
    # Initialize and prepare screen
    pygame.init()
    screen = pygame.display.set_mode(WINSIZE)
    pygame.display.set_caption('Bouncing Strategies    University of Illinois     November 2011')
    white = 255, 240, 200
    black = 20, 20, 40    
    green = 50, 130, 50
    screen.fill(black)
    pint = (0.0,0.0)

    # This sets the billiard boundary
    poly = bigpoly

    # Set the initial ball state (x,y,theta)
    state = (200.0, 200.0, 2.0)

    last_bounce_edge = -1
    pygame.draw.polygon(screen,white,PolyToWindowScale(poly),5)

    for i in range(NUMBOUNCES):

        psize = len(poly)
        closest_bounce = MAXDIST
        bnormal = -1.0  # The inward edge normal of the bounce point

        for j in range(psize):
            if (j != last_bounce_edge):
                # Consider the next edge
                v1 = poly[j]
                v2 = poly[(j+1) % psize]
                x1 = state[0]
                y1 = state[1]
                x2 = v1[0]
                y2 = v1[1]
                x3 = v2[0]
                y3 = v2[1]
                a = y3 - y2
                b = x2 - x3
                c = y2*(x3-x2) - x2*(y3-y2)
                # The line parameter t; needs divide by zero check! 
                t = (-c - b*y1 - a*x1)/(a*cos(state[2])+b*sin(state[2]))
                pint = (x1 + cos(state[2])*t, y1 + sin(state[2])*t)
                
                # Find closest bounce for which t > 0
                pdist = PointDistance(pint,(state[0],state[1]))
                if ((t > 0) and (pdist < closest_bounce) and
                    BouncePointInEdge((x1,y1),pint,v1,v2)):
                    bounce_point = pint
                    closest_bounce = pdist
                    bnormal = FixAngle(pi/2.0 + 
                                       atan2(poly[(j+1)%psize][1]-poly[j][1],\
                                             poly[(j+1)%psize][0]-poly[j][0]))
                    bounce_edge = j
#                    print "bnormal:",bnormal
#                    print "pdist:",pdist,"closest_bounce:",closest_bounce,"pint:",pint

#            pygame.draw.circle(screen,green,PointToWindowScale(pint),5)
#        raw_input("Press Enter to continue...")

#        print "closest_bounce:",closest_bounce,"bounce_point:",bounce_point
        pygame.draw.line(screen,green,PointToWindowScale(bounce_point),\
                         PointToWindowScale((state[0],state[1])))
        pygame.display.update()
#        print "state:",state
#        sleep(1.0)

# Set the last argument to PerformBounce:
# 0 = random, 1 = right angle, 2 = billiard
        state = PerformBounce(state,bounce_point,bnormal,2)
        last_bounce_edge = bounce_edge

        for e in pygame.event.get():
	   if e.type == QUIT or (e.type == KEYUP and e.key == K_ESCAPE):
	      sys.exit("Leaving because you requested it.")
    while (1):
       1 == 1

# if python says run, then we should run
if __name__ == '__main__':
    main()


